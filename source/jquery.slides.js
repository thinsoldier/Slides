// SlidesJS 3.0.4

// Documentation and examples http://slidesjs.com
// Support forum http://groups.google.com/group/slidesjs
// Created by Nathan Searles http://nathansearles.com

// Version: 3.0.4
// Updated: June 26th, 2013

// SlidesJS is an open source project, contribute at GitHub:
// https://github.com/nathansearles/Slides

// (c) 2013 by Nathan Searles

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

// http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated by CoffeeScript 1.6.1
(function() {

  (function($, window, document) {
    var Plugin, defaults, pluginName;
    pluginName = "slidesjs";
    defaults = {
      // Set the default width of the slideshow.
      width: 940,
      // Set the default height of the slideshow.
      height: 528,
      // Set the first slide in the slideshow.
      start: 1,
      navigation: {
        // Next and previous button settings.
        active: true,
        // [boolean] Create next and previous buttons.
        // You can set to false and use your own next/prev buttons.
        // User defined next/prev buttons must have the following:
        // previous: class="slidesjs-previous slidesjs-navigation"
        // next: class="slidesjs-next slidesjs-navigation"
        effect: "slide"
        // [string] Can be either "slide" or "fade".
      },
      pagination: {
        // Pagination settings
        active: true,
        // [boolean] Create pagination items.
        effect: "slide"
        // [string] Can be either "slide" or "fade".
      },
      play: {
        // Play and stop button setting.
        active: false,
        // [boolean] Create the play and stop buttons.
        effect: "slide",
        // [string] Can be either "slide" or "fade".
        interval: 5000,
        // [number] Time spent on each slide in milliseconds.
        auto: false,
        // [boolean] Start playing the slideshow on load
        swap: true,
        // [boolean] show/hide stop and play buttons
        pauseOnHover: false,
        // [boolean] pause a playing slideshow on hover
        restartDelay: 2500
        // [number] restart delay on an inactive slideshow
      },
      effect: {
        slide: {
        // Slide effect settings.
          speed: 500
          // [number] Speed in milliseconds of the slide animation.
        },
        fade: {
          speed: 300,
          // [number] Speed in milliseconds of the fade animation.
          crossfade: true
          // [boolean] Cross-fade the transition
        }
      },
      callback: {
        loaded: function() {},
        // [function] Called when slides is loaded
        start: function() {},
        // [function] Called when animation has started
        complete: function() {}
        // [function] Called when animation is complete
      }
    };
    
    Plugin = (function() {

      function Plugin(element, options) {
        this.element = element;
        this.options = $.extend(true, {}, defaults, options);
        this._defaults = defaults;
        this._name = pluginName;
        this.init();
      }

      return Plugin;

    })();
    
    Plugin.prototype.init = function() {
      var $element, nextButton, pagination, playButton, prevButton, stopButton,
        _this = this;
      $element = $(this.element);
      this.data = $.data(this);
      
      // Set data
      $.data(this, "animating", false);
      $.data(this, "total", $element.children().not(".slidesjs-navigation", $element).length);
      $.data(this, "current", this.options.start - 1);
      $.data(this, "vendorPrefix", this._getVendorPrefix());
      
      // Detect touch device
      if (typeof TouchEvent !== "undefined") {
        $.data(this, "touch", true);
        this.options.effect.slide.speed = this.options.effect.slide.speed / 2;
      }
      
      // Hide overflow
      $element.css({
        overflow: "hidden"
      });
      
      // Create container
      $element.slidesContainer = $element.children().not(".slidesjs-navigation", $element).wrapAll("<div class='slidesjs-container'>", $element).parent().css({
        overflow: "hidden",
        position: "relative"
      });
      
      // Create control div
      $(".slidesjs-container", $element)
      .wrapInner("<div class='slidesjs-control'>", $element)
      .children();
      
      // Setup control div
      $(".slidesjs-control", $element).css({
        position: "relative",
        left: 0
      });
      
      // Setup slides
      $(".slidesjs-control", $element).children().addClass("slidesjs-slide").css({
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        zIndex: 0,
        display: "none",
        webkitBackfaceVisibility: "hidden"
      });
      
      // Assign an index to each slide
      $.each($(".slidesjs-control", $element).children(), function(i) {
        var $slide;
        $slide = $(this);
        return $slide.attr("slidesjs-index", i);
      });
      
      
      if (this.data.touch) {
        // Bind touch events, if supported
        $(".slidesjs-control", $element).on("touchstart", function(e) {
          return _this._touchstart(e);
        });
        
        $(".slidesjs-control", $element).on("touchmove", function(e) {
          return _this._touchmove(e);
        });
        
        $(".slidesjs-control", $element).on("touchend", function(e) {
          return _this._touchend(e);
        });
      }
      
      // Fades in slideshow, your slideshow ID must be display:none in your CSS
      $element.fadeIn(0);
      
      // Update sets width/height of slideshow
      this.update();
      
      // If touch device setup next slides
      if (this.data.touch) {
        this._setuptouch();
      }
      
      // Fade in start slide
      $(".slidesjs-control", $element).children(":eq(" + this.data.current + ")").eq(0).fadeIn(0, function() {
        return $(this).css({
          zIndex: 10
        });
      });
      
      
      if (this.options.navigation.active) {
        // Create next/prev buttons
        prevButton = $("<a>", {
          "class": "slidesjs-previous slidesjs-navigation",
          href: "#",
          title: "Previous",
          text: "Previous"
        }).appendTo($element);
        
        nextButton = $("<a>", {
          "class": "slidesjs-next slidesjs-navigation",
          href: "#",
          title: "Next",
          text: "Next"
        }).appendTo($element);
      }
      
      // bind click events
      $(".slidesjs-next", $element).click(function(e) {
        e.preventDefault();
        _this.stop(true);
        return _this.next(_this.options.navigation.effect);
      });
      
      $(".slidesjs-previous", $element).click(function(e) {
        e.preventDefault();
        _this.stop(true);
        return _this.previous(_this.options.navigation.effect);
      });
      
      if (this.options.play.active) {
        playButton = $("<a>", {
          "class": "slidesjs-play slidesjs-navigation",
          href: "#",
          title: "Play",
          text: "Play"
        }).appendTo($element);
        
        stopButton = $("<a>", {
          "class": "slidesjs-stop slidesjs-navigation",
          href: "#",
          title: "Stop",
          text: "Stop"
        }).appendTo($element);
        
        playButton.click(function(e) {
          e.preventDefault();
          return _this.play(true);
        });
        
        stopButton.click(function(e) {
          e.preventDefault();
          return _this.stop(true);
        });
        
        if (this.options.play.swap) {
          stopButton.css({
            display: "none"
          });
        }
      }
      
      
      
      if (this.options.pagination.active) {
        pagination = $("<ul>", {
          "class": "slidesjs-pagination"
        }).appendTo($element);
        
        // Create a list item and anchor for each slide
        $.each(new Array(this.data.total), function(i) {
          var paginationItem, paginationLink;
          paginationItem = $("<li>", {
            "class": "slidesjs-pagination-item"
          }).appendTo(pagination);
          
          paginationLink = $("<a>", {
            href: "#",
            "data-slidesjs-item": i,
            html: i + 1
          }).appendTo(paginationItem);
          
          // bind click events
          return paginationLink.click(function(e) {
            e.preventDefault();
            _this.stop(true);
            return _this.goto(($(e.currentTarget).attr("data-slidesjs-item") * 1) + 1);
          });
        });
      }
      
      // Bind update on browser resize
      $(window).bind("resize", function() {
        return _this.update();
      });
      
      // Set start pagination item to active
      this._setActive();
      
      // Auto play slideshow
      if (this.options.play.auto) {
        this.play();
      }
      
      // Slides has loaded
      return this.options.callback.loaded(this.options.start);
    };
    
    // this._setActive()
    // Sets the active slide in the pagination
    Plugin.prototype._setActive = function(number) {
      var $element, current;
      $element = $(this.element);
      this.data = $.data(this);
      
      // Get the current slide index
      current = number > -1 ? number : this.data.current;
      
      // Set active slide in pagination
      $(".active", $element).removeClass("active");
      return $(".slidesjs-pagination li:eq(" + current + ") a", $element).addClass("active");
    };
    
    // this.update()
    // Update the slideshow size on browser resize
    Plugin.prototype.update = function() {
      var $element, height, width;
      $element = $(this.element);
      this.data = $.data(this);
      
      // Hide all slides except current
      $(".slidesjs-control", $element).children(":not(:eq(" + this.data.current + "))").css({
        display: "none",
        left: 0,
        zIndex: 0
      });
      
      // Get the new width and height
      width = $element.width();
      height = (this.options.height / this.options.width) * width;
      
      // Store new width and height
      this.options.width = width;
      this.options.height = height;
      
      // Set new width and height
      return $(".slidesjs-control, .slidesjs-container", $element).css({
        width: width,
        height: height
      });
    };
    
    // this.next()
    // Next mechanics
    Plugin.prototype.next = function(effect) {
      var $element;
      $element = $(this.element);
      this.data = $.data(this);
      
      // Set the direction
      $.data(this, "direction", "next");
      
      // Slides or fade effect
      if (effect === void 0) {
        effect = this.options.navigation.effect;
      }
      if (effect === "fade") {
        return this._fade();
      } else {
        return this._slide();
      }
    };
    
    // this.previous()
    // Previous mechanics
    Plugin.prototype.previous = function(effect) {
      var $element;
      $element = $(this.element);
      this.data = $.data(this);

      // Set the direction
      $.data(this, "direction", "previous");
      if (effect === void 0) {
        effect = this.options.navigation.effect;
      }

      // Slides or fade effect
      if (effect === "fade") {
        return this._fade();
      } else {
        return this._slide();
      }
    };
    
    // this.goto()
    // Pagination mechanics
    Plugin.prototype.goto = function(number) {
      var $element, effect;
      $element = $(this.element);
      this.data = $.data(this);
      
      // Set effect to default if not defined
      if (effect === void 0) {
        effect = this.options.pagination.effect;
      }
      
      // Error correction if slide doesn't exists
      if (number > this.data.total) {
        number = this.data.total;
      } else if (number < 1) {
        number = 1;
      }
      
      if (typeof number === "number") {
        if (effect === "fade") {
          return this._fade(number);
        } else {
          return this._slide(number);
        }
      } else if (typeof number === "string") {
        if (number === "first") {
          if (effect === "fade") {
            return this._fade(0);
          } else {
            return this._slide(0);
          }
        } else if (number === "last") {
          if (effect === "fade") {
            return this._fade(this.data.total);
          } else {
            return this._slide(this.data.total);
          }
        }
      }
    };
    
    // this._setuptouch()
    // Setup slideshow for touch
    Plugin.prototype._setuptouch = function() {
      var $element, next, previous, slidesControl;
      $element = $(this.element);
      this.data = $.data(this);
      
      // Define slides control
      slidesControl = $(".slidesjs-control", $element);
      
      // Get next/prev slides around current slide
      next = this.data.current + 1;
      previous = this.data.current - 1;
      
      // Create the loop
      if (previous < 0) {
        previous = this.data.total - 1;
      }
      if (next > this.data.total - 1) {
        next = 0;
      }
      
      // By default next/prev slides are hidden, show them when on touch device
      slidesControl.children(":eq(" + next + ")").css({
        display: "block",
        left: this.options.width
      });
      return slidesControl.children(":eq(" + previous + ")").css({
        display: "block",
        left: -this.options.width
      });
    };
    
    // this._touchstart()
    // Start touch
    Plugin.prototype._touchstart = function(e) {
      var $element, touches;
      $element = $(this.element);
      this.data = $.data(this);
      touches = e.originalEvent.touches[0];
      
      // Setup the next and previous slides for swiping
      this._setuptouch();
      
      // Start touch timer
      $.data(this, "touchtimer", Number(new Date()));
      
      // Set touch position
      $.data(this, "touchstartx", touches.pageX);
      $.data(this, "touchstarty", touches.pageY);
      
      // Stop event from bubbling up
      return e.stopPropagation();
    };
    
    // @_touchend()
    // Animates the slideshow when touch is complete
    Plugin.prototype._touchend = function(e) {
      var $element, duration, prefix, slidesControl, timing, touches, transform,
        _this = this;
        
      $element = $(this.element);
      this.data = $.data(this);
      touches = e.originalEvent.touches[0];
      
      // Define slides control
      slidesControl = $(".slidesjs-control", $element);
      
      // Slide has been dragged to the right, goto previous slide
      if (slidesControl.position().left > this.options.width * 0.5 || slidesControl.position().left > this.options.width * 0.1 && (Number(new Date()) - this.data.touchtimer < 250)) {
        $.data(this, "direction", "previous");
        this._slide();
      // Slide has been dragged to the left, goto next slide
      } else if (slidesControl.position().left < -(this.options.width * 0.5) || slidesControl.position().left < -(this.options.width * 0.1) && (Number(new Date()) - this.data.touchtimer < 250)) {
        $.data(this, "direction", "next");
        this._slide();
      } else {
      // Slide has not been dragged far enough, animate back to 0 and reset
        // Get the browser's vendor prefix
        prefix = this.data.vendorPrefix;
        
        // Create CSS3 styles based on vendor prefix
        transform = prefix + "Transform";
        duration = prefix + "TransitionDuration";
        timing = prefix + "TransitionTimingFunction";
        
        // Set CSS3 styles
        slidesControl[0].style[transform] = "translateX(0px)";
        slidesControl[0].style[duration] = this.options.effect.slide.speed * 0.85 + "ms";
      }
      
      // Rest slideshow
      slidesControl.on("transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd", function() {
        // Get the browser's vendor prefix
        prefix = _this.data.vendorPrefix;
        
        // Create CSS3 styles based on vendor prefix
        transform = prefix + "Transform";
        duration = prefix + "TransitionDuration";
        timing = prefix + "TransitionTimingFunction";
        
        // Set CSS3 styles
        slidesControl[0].style[transform] = "";
        slidesControl[0].style[duration] = "";
        return slidesControl[0].style[timing] = "";
      });
      
      // Stop event from bubbling up
      return e.stopPropagation();
    };
    
    // this._touchmove()
    // Moves the slide on touch
    Plugin.prototype._touchmove = function(e) {
      var $element, prefix, slidesControl, touches, transform;
      
      $element = $(this.element);
      this.data = $.data(this);
      touches = e.originalEvent.touches[0];
      
      // Get the browser's vendor prefix
      prefix = this.data.vendorPrefix;
      
      // Define slides control
      slidesControl = $(".slidesjs-control", $element);
      
      // Create CSS3 styles based on vendor prefix
      transform = prefix + "Transform";
      
      // Check if user is trying to scroll vertically
      $.data(this, "scrolling", Math.abs(touches.pageX - this.data.touchstartx) < Math.abs(touches.pageY - this.data.touchstarty));
      
      // Set CSS3 styles
      if (!this.data.animating && !this.data.scrolling) {
        // Prevent default scrolling
        e.preventDefault();
        this._setuptouch();
        slidesControl[0].style[transform] = "translateX(" + (touches.pageX - this.data.touchstartx) + "px)";
      }
      
      // Stop event from bubbling up
      return e.stopPropagation();
    };
    
    // this.play()
    // Play the slideshow
    Plugin.prototype.play = function(next) {
      var $element, currentSlide, slidesContainer,
        _this = this;
      $element = $(this.element);
      this.data = $.data(this);
      
      // Check if the slideshow is already playing
      if (!this.data.playInterval) {
        // If next is true goto next slide
        if (next) {
          currentSlide = this.data.current;
          this.data.direction = "next";
          if (this.options.play.effect === "fade") {
            this._fade();
          } else {
            this._slide();
          }
        }
        
        // Set and store interval
        $.data(this, "playInterval", setInterval((function() {
          currentSlide = _this.data.current;
          _this.data.direction = "next";
          if (_this.options.play.effect === "fade") {
            return _this._fade();
          } else {
            return _this._slide();
          }
        }), this.options.play.interval));
        
        // Define slides container
        slidesContainer = $(".slidesjs-container", $element);
        
        if (this.options.play.pauseOnHover) {
          // Prevent event build up
          slidesContainer.unbind();
          
          // Stop/pause slideshow on mouse enter
          slidesContainer.bind("mouseenter", function() {
            return _this.stop(); // !!! THIS METHODS CONTENT IS QUITE DIFFERENT FROM THE COFFEESCRIPT file line 516
          });
          
          // Play slideshow on mouse leave
          slidesContainer.bind("mouseleave", function() {
            if (_this.options.play.restartDelay) {
              return $.data(_this, "restartDelay", setTimeout((function() {
                return _this.play(true);
              }), _this.options.play.restartDelay));
            } else {
              return _this.play();
            }
          });
        }
        
        $.data(this, "playing", true);
        
        // Add "slidesjs-playing" class to "slidesjs-play" button
        $(".slidesjs-play", $element).addClass("slidesjs-playing");
        
        if (this.options.play.swap) {
          $(".slidesjs-play", $element).hide();
          return $(".slidesjs-stop", $element).show();
        }
      }
    };
    
    // @stop()
    // Stops a playing slideshow
    Plugin.prototype.stop = function(clicked) {
      var $element;
      $element = $(this.element);
      this.data = $.data(this);
      
      // Clear play interval
      clearInterval(this.data.playInterval);

      if (this.options.play.pauseOnHover && clicked) {
        // Prevent event build up
        $(".slidesjs-container", $element).unbind();
      }
      
      // Reset slideshow
      $.data(this, "playInterval", null);
      $.data(this, "playing", false);
      $(".slidesjs-play", $element).removeClass("slidesjs-playing");
      
      if (this.options.play.swap) {
        $(".slidesjs-stop", $element).hide();
        return $(".slidesjs-play", $element).show();
      }
    };
    
    // this._slide()
    // CSS3 and JavaScript slide animations
    Plugin.prototype._slide = function(number) {
      var $element, currentSlide, direction, duration, next, prefix, slidesControl, timing, transform, value,
        _this = this;
      $element = $(this.element);
      this.data = $.data(this);
      
      if (!this.data.animating && number !== this.data.current + 1) {
        // Set animating to true
        $.data(this, "animating", true);
        
        // Get current slide
        currentSlide = this.data.current;
        
        if (number > -1) {
          number = number - 1;
          value = number > currentSlide ? 1 : -1;
          direction = number > currentSlide ? -this.options.width : this.options.width;
          next = number;
        } else {
          value = this.data.direction === "next" ? 1 : -1;
          direction = this.data.direction === "next" ? -this.options.width : this.options.width;
          next = currentSlide + value;
        }
        
        // Loop from first to last slide
        if (next === -1) {
          next = this.data.total - 1;
        }
        
        // Loop from last to first slide
        if (next === this.data.total) {
          next = 0;
        }
        
        // Set next slide pagination item to active
        this._setActive(next);
        
        // Define slides control
        slidesControl = $(".slidesjs-control", $element);
        
        // When changing from touch to pagination reset touch slide setup
        if (number > -1) {
          slidesControl.children(":not(:eq(" + currentSlide + "))").css({
            display: "none",
            left: 0,
            zIndex: 0
          });
        }
        
        // Setup the next slide
        slidesControl.children(":eq(" + next + ")").css({
          display: "block",
          left: value * this.options.width,
          zIndex: 10
        });
        
        //Start the slide animation
        this.options.callback.start(currentSlide + 1);
        
        if (this.data.vendorPrefix) {
          // If supported use CSS3 for the animation
          // Get the browser's vendor prefix
          prefix = this.data.vendorPrefix;
          
          // Create CSS3 styles based on vendor prefix
          transform = prefix + "Transform";
          duration = prefix + "TransitionDuration";
          timing = prefix + "TransitionTimingFunction";
          
          // Set CSS3 styles
          slidesControl[0].style[transform] = "translateX(" + direction + "px)";
          slidesControl[0].style[duration] = this.options.effect.slide.speed + "ms";
          
          return slidesControl.on("transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd", function() {
            // Clear styles
            slidesControl[0].style[transform] = "";
            slidesControl[0].style[duration] = "";
            
            // Reset slideshow
            slidesControl.children(":eq(" + next + ")").css({ left: 0 });
            slidesControl.children(":eq(" + currentSlide + ")").css({
              display: "none",
              left: 0,
              zIndex: 0
            });
            
            // Set the new slide to the current
            $.data(_this, "current", next);
            
            // // Set animating to false
            $.data(_this, "animating", false);
            
            // Unbind transition callback to prevent build up
            slidesControl.unbind("transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd");
            
            // Hide all slides except current
            slidesControl.children(":not(:eq(" + next + "))").css({
              display: "none",
              left: 0,
              zIndex: 0
            });
            
            // If touch device setup next slides
            if (_this.data.touch) { _this._setuptouch(); }
            
            // End of the animation, call complete callback
            return _this.options.callback.complete(next + 1);
          });
        } else {
          // If CSS3 isn't support use JavaScript for the animation
          return slidesControl.stop().animate({
            left: direction
          }, this.options.effect.slide.speed, (function() {
            slidesControl.css({
              left: 0
            });
            slidesControl.children(":eq(" + next + ")").css({
              left: 0
            });
            return slidesControl.children(":eq(" + currentSlide + ")").css({
              display: "none",
              left: 0,
              zIndex: 0
            }, 
              // Set the new slide to the current
              $.data(_this, "current", next), 
              
              // Set animating to false
              $.data(_this, "animating", false), 
              
              // End of the animation, call complete callback
              _this.options.callback.complete(next + 1));
          }));
        }
      }
    };
    
    // this._fade()
    // Fading and cross fading
    Plugin.prototype._fade = function(number) {
      var $element, currentSlide, next, slidesControl, value,
        _this = this;
      $element = $(this.element);
      this.data = $.data(this);
      
      // Check if not currently animating and the selected slide is not the current slide
      if (!this.data.animating && number !== this.data.current + 1) {
        
        // Set animating to true
        $.data(this, "animating", true);
        
        // Get current slide
        currentSlide = this.data.current;
        
        if (number) {
          // Specific slide has been called
          number = number - 1;
          value = number > currentSlide ? 1 : -1;
          next = number;
        } else {
          // Next/prev slide has been called
          value = this.data.direction === "next" ? 1 : -1;
          next = currentSlide + value;
        }
        
        // Loop from first to last slide
        if (next === -1) {
          next = this.data.total - 1;
        }
        
        // Loop from last to first slide
        if (next === this.data.total) {
          next = 0;
        }
        
        // Set next slide pagination item to active
        this._setActive(next);
        
        // Define slides control
        slidesControl = $(".slidesjs-control", $element);
        
        // Setup the next slide
        slidesControl.children(":eq(" + next + ")").css({
          display: "none",
          left: 0,
          zIndex: 10
        });
        
        // Start of the animation, call the start callback
        this.options.callback.start(currentSlide + 1);
        
        if (this.options.effect.fade.crossfade) {
          // Fade out current slide to next slide
          slidesControl.children(":eq(" + this.data.current + ")")
          .stop()
          .fadeOut(this.options.effect.fade.speed);
          
          // Fade in to next slide
          return slidesControl.children(":eq(" + next + ")")
          .stop()
          .fadeIn(this.options.effect.fade.speed, (function() {
            // Reset slides
            slidesControl.children(":eq(" + next + ")").css({ zIndex: 0 });
            
            // Set animating to false
            $.data(_this, "animating", false);
            
            // Set the new slide to the current
            $.data(_this, "current", next);
            
            // End of the animation, call complete callback
            return _this.options.callback.complete(next + 1);
          }));
        } else {
          // Fade to next slide
          return slidesControl.children(":eq(" + currentSlide + ")")
          .stop().fadeOut(this.options.effect.fade.speed, (function() {
            // Reset slides
            slidesControl.children(":eq(" + next + ")")
            .stop()
            .fadeIn(_this.options.effect.fade.speed, (function() {
              // Reset slides
              return slidesControl.children(":eq(" + next + ")").css({ zIndex: 10 });
            }));
            
            // Set animating to false
            $.data(_this, "animating", false);
            
            // Set the new slide to the current
            $.data(_this, "current", next);
            
            // End of the animation, call complete callback
            return _this.options.callback.complete(next + 1);
          }));
        }
      }
    };
    
    // this._getVendorPrefix()
    // Check if the browser supports CSS3 Transitions
    Plugin.prototype._getVendorPrefix = function() {
      var body, i, style, transition, vendor;
      
      body = document.body || document.documentElement;
      style = body.style;
      transition = "transition";
      
      vendor = ["Moz", "Webkit", "Khtml", "O", "ms"];
      transition = transition.charAt(0).toUpperCase() + transition.substr(1);
      
      i = 0;
      
      while (i < vendor.length) {
        if (typeof style[vendor[i] + transition] === "string") {
          return vendor[i];
        }
        i++;
      }
      return false;
    };
    
    // Plugin constructor
    return $.fn[pluginName] = function(options) {
      return this.each(function() {
        if (!$.data(this, "plugin_" + pluginName)) {
          return $.data(this, "plugin_" + pluginName, new Plugin(this, options));
        }
      });
    };
  })(jQuery, window, document);

}).call(this);
